
=============================================================================================
--- CHECKOUT ---

	PS: APÓS A CRIAÇÃO DE UMA NOVA BRANCH, OU A QUALQUER MOMENTO QUE VOCÊ DESEJE MUDAR A BRANCH EM QUE VOCÊ ESTEJA TRABALHANDO, VOCÊ PODERÁ UTILIZAR O COMANDO:
	-> GIT CHECKOUT <branch>

	EM ALGUM DETERMINADO MOMENTO, SEU PROJETO JÁ TERÁ MUITOS COMMITS. E EM ALGUM MOMENTO VOCÊ VAI PRECISAR VOLTAR ATRÁS EM UM COMMIT ESPECÍFICO. PARA CONSEGUIR TRAZER QUALQUER COMMIT ESPECÍFICO BASTA UTILIZAR O COMANDO:
	-> GIT CHECKOUT <commit> <file>

	PARA PODER OBTER O CÓDIGO DO COMMIT A SER RECUPERADO, UTILIZE DO GIT LOG PARA VERIFICAR AS INFORMAÇÕES SOBRE O COMMIT. COM O CÓDIGO GERADO, UTILIZE NO EXEMPLO E O RETORNO SERÁ A ATUALIZAÇÃO (NO CASO, RETORNO) PARA OS ARQUIVOS COMO ESTAVAM NAQUELE COMMIT.

	AQUI DUAS SITUAÇÕES PODEM ACONTECER. A UTILIZAÇÃO DESTES CÓDIGO MAIS ANTIGOS EM UMA OUTRA VERSÃO. E COM ESSA IDEIA O GIT SUGERE A CRIAÇÃO DE UMA BRANCH. ESSA OUTRA OPÇÃO, NÓS VEREMOS DEPOIS. PARA AGORA, VAMOS UTILIZAR A OUTRA SITUAÇÃO. NÃO MODIFICAMOS NADA E QUEREMOS VOLTAR PARA A MAIS ATUAL. PARA VOLTAR, BASTA DIGITAR O COMANDO:
	-> GIT CHECKOUT MASTER

	E VOCÊ ESTARÁ DE VOLTA A VERSÃO MAIS ATUAL DO PROJETO.

*** OUTROS COMANDOS UTILIZANDO O GIT CHECKOUT ***

	-> GIT CHECKOUT --<caminho/arquivo>
	ESSE COMANDO IRÁ TE PERMITIR DESFAZER DE TODAS AS ALTERAÇÕES QUE NÃO ESTEJAM NO STAGE (A ALTERAÇÃO ACONTECE QUANDO O COMANDO GIT ADD É UTILIZADO) DESDE O ÚLTIMO COMMIT.

	-> GIT CHECKOUT HEAD -- <caminho/arquivo>
	ESSE COMANDO PERMITE DESFAZER AS ALTERAÇÕES DESDE O ÚLTIMO COMMIT, INCLUÍNDO O STAGE (A ALTERAÇÃO ACONTECE QUANDO O COMANDO GIT ADD É UTILIZADO).

	-> GIT CHECKOUT -B <nova_branch>

=============================================================================================
--- GIT REVERT ---
	
	OUTRO COMANDO UTILIZANDO PARA DESFAZER. ESSE COMANDO IRÁ CRIAR UM NOVO COMMIT, DESFAZENDO TODAS AS ALTERAÇÕES ATÉ O COMMIT ESPECIFICADO. PARA QUE O COMANDO SEJA UTILIZADO, PRIMEIRO DEVEMOS SABER QUAL O CÓDIGO DO COMMIT QUE QUEREMOS RETORNAR. UMA FORMA DE CONSEGUIR ESSE CÓDIGO É UTILIZANDO O COMANDO GIT LOG. O RETORNO SERÁ DOS ÚLTIMOS COMMITS ENVIADOS. E COM A POSSE DESSE CÓDIGO, BASTA UTILIZAR O COMANDO:
	-> GIT REVERT <código commit>

	NÃO HÁ A NECESSIDADE DE COPIAR O CÓDIGO POR COMPLETO. NA MÉDIA, 6 CARACTERES SÃO SUFICIENTES PARA O COMMIT SER ENCONTRADO, POIS CADA CÓDIGO DESSES É ÚNICO.

=============================================================================================
--- GIT DIFF ---
	
	ESSE É OUTRO COMANDO DO GIT BASTANTE INTERESSANTE DE UTILIZAR. O RETORNO QUE ESSE COMANDO TRÁS É A DIFERENÇA ENTRE DOIS COMMITS. PARA UTILIZAR ESSE COMANDO É NECESSÁRIO POSSUIR DOIS CÓDIGOS DE DOIS COMMITS DIFERENTES. PARA ACESSAR ESSES CÓDIGOS UMA MANEIRA É UTILIZAR O GIT LOG.
	-> GIT DIFF <código commit1> <código commit2>

	O RETORNO IRÁ MOSTRAR AS DIFERENÇAS ENTRE OS COMMITS.

=============================================================================================
--- GIT RESET ---

	ESTE É UM COMANDO VERSÁTIL E ÚTIL. MAS DEVE SER USADO COM CUIDADO. HÁ ALGUMAS FORMAS DE UTILIZAR ELE. BASICAMENTE VOCÊ PODE UTILIZAR O RESET E O RESET --HARD PARA DESFAZER TODAS AS ALTERAÇÕES LOCAIS QUE VOCÊ FEZ E VOLTAR OS ARQUIVOS PARA O ESTADO INICIAL DO PUSH. ENTRETANTO, SE VOCÊ ADICIONAR O CÓDIGO DO COMMIT, O COMANDO IRÁ APAGAR OS COMMITS FEITOS DEPOIS DELE. E OUTRAS PESSOAS OU EMPRESAS PODEM ESTAREM USANDO ESSES ARQUIVOS E ISSO PODE TRAZER GRANDES PROBLEMAS. MAS, PARA O INICIANTE, APENAS O COMANDO:
	-> GIT RESET (--HARD)

	:É UM BOM COMANDO PARA VOLTAR OS ARQUIVOS ATÉ O PONTO INICIAL DO PUSH. PARA RESETAR REPOSITÓRIOS E REMOVER TODAS AS ALTERAÇÕES É MELHOR APROFUNDAMENTO TÉCNICO SOBRE O COMANDO.

=============================================================================================
--- BRANCHING ---
	
	* RAMIFICAÇÕES *
	BRANCH NADA MAIS É DO QUE UMA RAMIFICAÇÃO DO CÓDIGO QUE ESTÁ SENDO CONSTRUÍDO. POR PADRÃO, A PRINCIPAL BRANCH É A MASTER. UM MESMO PROJETO PODE TER DIFERENTES BRANCHS. UTILIZANDO O COMANDO:
	-> GIT BRANCH

	:VOCÊ PODERÁ VISUALIZAR TODAS AS BRANCHS DISPONÍVEIS. OBS: FIQUE ATENTO, POIS ESSE COMANDO TRÁS A INFORMAÇÃO DE FORMA 'LOCAL'. E PARA TER TODAS AS BRANCHS EM UTILIZAÇÃO TALVEZ SEJA NECESSÁRIO DAR O GIT PULL PARA AS INFORMAÇÕES SEREM MAIS CORRETAS. O RETORNO SERÁ TODAS AS BRANCHS EXISTENTES.
	HÁ AINDA OUTROS COMANDOS QUE PODEM SER UTILIZADOS, COMANDOS ESSES DERIVADOS DO GIT BRANCH. HÁ:
	-> GIT BRANCH <nova_branch>

	QUE COMO ESPERADO, CRIA UMA NOVA BRANCH A PARTIR DA BRANCH ATUAL. HÁ UMA FORMA DE EXCLUIR A BRANCH, UTILIZANDO O COMANDO:
	-> GIT BRANCH -D <branch>

	ESSE COMANDO IRÁ EXCLUIR A BRANCH, ENTÃO DEVE SER USADO COM CAUTELA E CERTEZA DE QUE A EXCLUSÃO PODE SER FEITA.

	

	ESSE COMANDO IRÁ TE COLOCAR NA BRANCH ESPECIFICADA. O RETORNO SERÁ A CONFIRMAÇÃO QUE VOCÊ FEZ A TROCA DE BRANCH. E A PARTIR DE AGORA, TODOS OS COMMITS QUE FOREM FEITOS, SERÃO FEITOS NESSA BRANCH E NÃO MAIS NA ANTIGA.

	COM A CRIAÇÃO DE UMA NOVA BRANCH, ALGUNS COMANDOS IRÃO TRAZER RETORNOS DIFERENTES; UM DELES É O GIT LOG.
=============================================================================================
--- GIT MERGE ---
	
	UM DOS COMANDOS MAIS COMPLEXOS ATÉ O MOMENTO. O MERGE SERVE PARA UNIR DUAS DIFERENTES BRANCHS. O MERGE IRÁ PEGAR UMA BASE COMUM ENTRE AS DUAS BRANCHS E APLICAR TODOS OS COMMITS QUE A BRANCH ATUAL NÃO POSSUI. CASO VOCÊ TENHA DUAS BRANCHS ('A' E 'B'), SENDO A 'B' A ÚLTIMA UTILIZADA; O MERGE TRARÁ TODOS OS COMMITS DE 'B' PARA 'A', ATUALIZANDO ASSIM A BRANCH 'A'. ENTRETANTO, SE NA SUA BRANCH 'A', VOCÊ FEZ COISAS QUE NÃO EXISTEM NA BRANCH 'B', SERÁ CRIADO UM COMMIT DE MERGE. PARA UTILIZAR O MERGE BASTA UTILIZAR O SEGUINTE COMANDO:
	-> GIT MERGE <branch>

	UTILIZANDO ESSE COMANDO É ESPERADO QUE HAJAM CONFLITOS NOS ARQUIVOS. O DESENVOLVEDOR DEVERÁ RESOLVER ESSES CONFLITOS. RESOLVIDO TODOS OS CONFLITOS, SERÁ CRIADO UM COMMIT DE MERGE.
=============================================================================================
--- GIT REBASE ---

	SEGUINDO NOS COMANDOS COMPLEXOS, TEMOS O REBASE. O REBASE É SEMELHANTE AO MARGE, PORÉM A DIFERENÇA FICA NA ORDEM DE APLICAR OS COMMITS. COM O REBASE, OS COMMITS NA FRENTE DA BASE SÃO REMOVIDOS TEMPORARIAMENTE, ENTÃO SÃO APLICADOS OS COMMITS DA OUTRA BRANCH E POR FIM, OS COMMITS QUE FORAM REMOVIDOS, SERÃO APLICADOS.
	TALVEZ SEJA NECESSÁRIO RESOLVER CONFLITOS.

